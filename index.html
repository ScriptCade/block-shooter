<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Block Buster FPS - Clean</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #f4f7f6; /* Clean light gray */
            font-family: 'Inter', 'Segoe UI', sans-serif;
            user-select: none;
            touch-action: none;
            color: #2c3e50;
        }
        canvas {
            display: block;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 30px;
            box-sizing: border-box;
        }
        .hud-text {
            font-weight: 800;
            letter-spacing: -0.5px;
        }
        #score-container {
            text-align: left;
        }
        #score-label {
            font-size: 14px;
            text-transform: uppercase;
            color: #7f8c8d;
            margin-bottom: 5px;
        }
        #score-display {
            font-size: 48px;
            color: #2c3e50;
            line-height: 1;
        }
        #highscore-display {
            font-size: 16px;
            color: #95a5a6;
            margin-top: 5px;
            font-weight: 600;
        }
        #powerup-status {
            font-size: 18px;
            color: #e74c3c;
            height: 30px;
            margin-top: 10px;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.3s;
        }
        #game-over-screen {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: #fff;
            padding: 50px;
            border-radius: 24px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.1);
            pointer-events: auto;
            min-width: 320px;
        }
        h1 { margin: 0 0 10px 0; font-size: 32px; color: #2c3e50; letter-spacing: -1px; }
        p { margin: 10px 0; color: #7f8c8d; font-size: 18px; }
        button {
            background: #2c3e50;
            border: none;
            color: white;
            padding: 18px 45px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            border-radius: 12px;
            margin-top: 25px;
            transition: all 0.2s ease;
            box-shadow: 0 4px 15px rgba(44, 62, 80, 0.2);
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(44, 62, 80, 0.3);
            background: #34495e;
        }
        button:active {
            transform: scale(0.98);
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div id="score-container" class="hud-text">
            <div id="score-label">Current Score</div>
            <div id="score-display">0</div>
            <div id="highscore-display">BEST: 0</div>
            <div id="powerup-status">MINIGUN ACTIVE</div>
        </div>
        <div class="hud-text" style="font-size: 14px; color: #95a5a6; text-align: right;">
            TAP TO SHOOT
        </div>
    </div>

    <div id="game-over-screen">
        <h1>System Full</h1>
        <p>The grid has reached capacity.</p>
        <div style="font-size: 42px; font-weight: 800; color: #2c3e50; margin: 20px 0;">
            <span id="final-score">0</span>
        </div>
        <button onclick="resetGame()">Try Again</button>
    </div>

    <script>
        /**
         * BLOCK BUSTER FPS - Clean Edition
         * Features: Falling blocks, Power-ups, Local Storage Highscore
         */

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        const scoreEl = document.getElementById('score-display');
        const highScoreEl = document.getElementById('highscore-display');
        const finalScoreEl = document.getElementById('final-score');
        const gameOverScreen = document.getElementById('game-over-screen');
        const powerupStatusEl = document.getElementById('powerup-status');

        // --- AUDIO SYSTEM ---
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();
        
        const playTone = (freq, type, duration, vol = 0.1) => {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            gain.gain.setValueAtTime(vol, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + duration);
        };

        const sfx = {
            shoot: () => {
                if (audioCtx.state === 'suspended') audioCtx.resume();
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(600, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(150, audioCtx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.1);
            },
            hit: () => playTone(200, 'sine', 0.1, 0.1),
            powerup: () => {
                playTone(800, 'sine', 0.3, 0.1);
                setTimeout(() => playTone(1200, 'sine', 0.4, 0.1), 100);
            },
            land: () => playTone(100, 'sine', 0.2, 0.1),
            gameOver: () => playTone(100, 'sawtooth', 0.8, 0.2)
        };

        // --- STORAGE HELPER ---
        // Safe wrapper to prevent crashing if cookies are blocked
        const Storage = {
            get: (key, def) => {
                try {
                    return parseInt(localStorage.getItem(key)) || def;
                } catch (e) {
                    console.warn('Storage access denied');
                    return def;
                }
            },
            set: (key, val) => {
                try {
                    localStorage.setItem(key, val);
                } catch (e) {
                    // Fail silently
                }
            }
        };

        // --- GAME STATE ---
        let width, height;
        let animationId;
        let lastTime = 0;
        let score = 0;
        let highScore = Storage.get('blockBusterHighScore', 0);
        let isGameOver = false;
        let shake = 0;

        // Grid
        const COLS = 8;
        let CELL_SIZE = 50; 
        const GRID_BOTTOM_MARGIN = 140; 
        const DANGER_Y = 120;

        // Entities
        let grid = []; 
        let fallingBlocks = [];
        let bullets = [];
        let particles = [];
        let powerups = [];

        // Input
        const mouse = { x: 0, y: 0, active: false, down: false };
        
        // Gameplay
        let spawnTimer = 0;
        let spawnInterval = 1200;
        
        // Power-Up System
        const UPGRADE_TYPES = {
            TRIPLE: { name: 'TRIPLE SHOT', color: '#e67e22', duration: 5000 },
            MINIGUN: { name: 'MINIGUN', color: '#e74c3c', duration: 4000 }
        };
        
        let activePowerUp = null;
        let powerUpTimer = 0;
        let lastShotTime = 0;
        const DEFAULT_FIRE_RATE = 200;
        const MINIGUN_FIRE_RATE = 80;

        // Palette
        const PALETTE = [
            '#3498db', '#2ecc71', '#9b59b6', '#f1c40f', '#e67e22', '#1abc9c'
        ];

        // --- RESIZE ---
        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            const maxBoardWidth = Math.min(550, width - 20);
            CELL_SIZE = Math.floor(maxBoardWidth / COLS);
            if(!mouse.active) {
                mouse.x = width / 2;
                mouse.y = height / 3;
            }
        }
        window.addEventListener('resize', resize);
        resize();

        // --- ENTITIES ---
        class Block {
            constructor(col, startY, color) {
                this.col = col;
                this.x = 0;
                this.y = startY;
                this.targetY = null;
                this.color = color;
                this.w = CELL_SIZE - 6;
                this.h = CELL_SIZE - 6;
                this.active = true;
            }
            draw(gridOffsetX) {
                this.x = gridOffsetX + this.col * CELL_SIZE + 3;
                ctx.fillStyle = 'rgba(0,0,0,0.1)';
                ctx.fillRect(this.x + 4, this.y + 7, this.w, this.h);
                ctx.fillStyle = this.color;
                roundRect(ctx, this.x, this.y + 3, this.w, this.h, 6);
                ctx.fill();
                ctx.fillStyle = 'rgba(255,255,255,0.15)';
                ctx.beginPath();
                ctx.roundRect(this.x, this.y + 3, this.w, this.h/2, [6,6,0,0]);
                ctx.fill();
            }
        }

        class PowerUpOrb {
            constructor() {
                this.x = Math.random() * (width - 100) + 50;
                this.y = -50;
                this.type = Math.random() > 0.5 ? 'TRIPLE' : 'MINIGUN';
                this.vy = Math.random() * 1.5 + 1;
                this.radius = 18;
                this.angle = 0;
                this.color = UPGRADE_TYPES[this.type].color;
            }
            update(timeScale) {
                this.y += this.vy * timeScale;
                this.angle += 0.05 * timeScale;
            }
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.translate(0, Math.sin(this.angle * 2) * 5);
                ctx.fillStyle = 'rgba(0,0,0,0.1)';
                ctx.beginPath();
                ctx.arc(5, 5, this.radius, 0, Math.PI*2);
                ctx.fill();
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI*2);
                ctx.fill();
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 12px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.type === 'TRIPLE' ? '3x' : 'MG', 0, 0);
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 0, this.radius + 4 + Math.sin(this.angle)*2, 0, Math.PI*2);
                ctx.stroke();
                ctx.restore();
            }
        }

        class Bullet {
            constructor(tx, ty, angleOffset = 0) {
                this.x = width / 2;
                this.y = height; 
                this.speed = 25;
                this.radius = 5;
                this.dead = false;
                const baseAngle = Math.atan2(ty - this.y, tx - this.x);
                const finalAngle = baseAngle + angleOffset;
                this.vx = Math.cos(finalAngle) * this.speed;
                this.vy = Math.sin(finalAngle) * this.speed;
                this.color = '#2c3e50';
            }
            update(timeScale) {
                this.x += this.vx * timeScale;
                this.y += this.vy * timeScale;
                if(this.y < -50 || this.x < 0 || this.x > width) this.dead = true;
            }
            draw() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
                ctx.fill();
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 6 + 2;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.life = 1.0;
                this.decay = Math.random() * 0.04 + 0.02;
                this.color = color;
                this.gravity = 0.2;
                this.size = Math.random() * 4 + 2;
            }
            update(timeScale) {
                this.x += this.vx * timeScale;
                this.y += this.vy * timeScale;
                this.vy += this.gravity * timeScale;
                this.life -= this.decay * timeScale;
            }
            draw() {
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.size, this.size);
                ctx.globalAlpha = 1.0;
            }
        }

        function roundRect(ctx, x, y, w, h, r) {
            if (ctx.roundRect) {
                ctx.beginPath();
                ctx.roundRect(x, y, w, h, r);
                ctx.closePath();
                return;
            }
            if (w < 2 * r) r = w / 2;
            if (h < 2 * r) r = h / 2;
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.arcTo(x + w, y, x + w, y + h, r);
            ctx.arcTo(x + w, y + h, x, y + h, r);
            ctx.arcTo(x, y + h, x, y, r);
            ctx.arcTo(x, y, x + w, y, r);
            ctx.closePath();
        }

        // --- INPUT ---
        function handleMove(x, y) {
            mouse.x = x;
            mouse.y = y;
            mouse.active = true;
        }

        window.addEventListener('mousemove', e => handleMove(e.clientX, e.clientY));
        window.addEventListener('mousedown', () => { mouse.down = true; });
        window.addEventListener('mouseup', () => { mouse.down = false; });
        
        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            mouse.down = true;
            handleMove(e.touches[0].clientX, e.touches[0].clientY);
        }, {passive: false});
        canvas.addEventListener('touchend', e => { e.preventDefault(); mouse.down = false; });
        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            handleMove(e.touches[0].clientX, e.touches[0].clientY);
        }, {passive: false});

        function attemptShoot(now) {
            let fireRate = activePowerUp?.type === 'MINIGUN' ? MINIGUN_FIRE_RATE : 0; 
            if (activePowerUp?.type === 'MINIGUN') {
                if (now - lastShotTime > fireRate) {
                    fireBullet();
                    lastShotTime = now;
                }
            }
        }
        
        window.addEventListener('mousedown', () => {
            if (isGameOver) return;
            if (activePowerUp?.type !== 'MINIGUN') fireBullet();
        });
        
        canvas.addEventListener('touchstart', () => {
             if (isGameOver) return;
             if (activePowerUp?.type !== 'MINIGUN') fireBullet();
        });

        function fireBullet() {
            if (activePowerUp?.type === 'TRIPLE') {
                bullets.push(new Bullet(mouse.x, mouse.y, -0.15));
                bullets.push(new Bullet(mouse.x, mouse.y, 0));
                bullets.push(new Bullet(mouse.x, mouse.y, 0.15));
            } else {
                bullets.push(new Bullet(mouse.x, mouse.y));
            }
            sfx.shoot();
            shake = 3;
        }

        function activatePowerUp(type) {
            activePowerUp = { type: type, ...UPGRADE_TYPES[type] };
            powerUpTimer = UPGRADE_TYPES[type].duration;
            sfx.powerup();
            powerupStatusEl.innerText = activePowerUp.name + " ACTIVE";
            powerupStatusEl.style.color = activePowerUp.color;
            powerupStatusEl.style.opacity = 1;
        }

        function addScore(points) {
            score += points;
            scoreEl.innerText = score;
            
            // Real-time Highscore Update
            if (score > highScore) {
                highScore = score;
                Storage.set('blockBusterHighScore', highScore);
                highScoreEl.innerText = `BEST: ${highScore}`;
                highScoreEl.style.color = '#e74c3c'; // Highlight when beaten
            }
        }

        // --- MAIN LOOP ---
        function init() {
            grid = Array(COLS).fill(null).map(() => []);
            fallingBlocks = [];
            bullets = [];
            particles = [];
            powerups = [];
            score = 0;
            scoreEl.innerText = 0;
            
            highScore = Storage.get('blockBusterHighScore', 0);
            highScoreEl.innerText = `BEST: ${highScore}`;
            highScoreEl.style.color = '#95a5a6';

            isGameOver = false;
            activePowerUp = null;
            gameOverScreen.style.display = 'none';
            powerupStatusEl.style.opacity = 0;
            
            spawnBlock();
            lastTime = performance.now();
            requestAnimationFrame(loop);
        }

        function spawnBlock() {
            const col = Math.floor(Math.random() * COLS);
            const color = PALETTE[Math.floor(Math.random() * PALETTE.length)];
            fallingBlocks.push(new Block(col, -CELL_SIZE, color));
            if (Math.random() < 0.08) powerups.push(new PowerUpOrb());
        }

        function createExplosion(x, y, color) {
            for(let i=0; i<8; i++) {
                particles.push(new Particle(x, y, color));
            }
        }

        function update(now) {
            let dt = now - lastTime;
            lastTime = now;

            // Cap dt to prevent spiraling if tab is backgrounded
            if (dt > 100) dt = 16.67; 
            
            // Time scale factor (approx 1.0 at 60fps)
            // If FPS drops to 30, timeScale becomes 2.0 (moving objects 2x distance per frame to keep up)
            const timeScale = dt / 16.67;

            if (isGameOver) return;

            if (mouse.down) attemptShoot(now);

            if (activePowerUp) {
                powerUpTimer -= dt;
                if (powerUpTimer <= 0) {
                    activePowerUp = null;
                    powerupStatusEl.style.opacity = 0;
                }
            }

            if (score > 0 && score % 150 === 0) spawnInterval = Math.max(400, 1200 - score);
            spawnTimer += dt;
            if (spawnTimer > spawnInterval) {
                spawnBlock();
                spawnTimer = 0;
            }

            if(shake > 0) shake *= 0.9;
            if(shake < 0.5) shake = 0;

            const gridWidth = COLS * CELL_SIZE;
            const gridOffsetX = (width - gridWidth) / 2;
            const floorY = height - GRID_BOTTOM_MARGIN;

            const fallSpeed = (180 + (score * 0.5)) * (dt / 1000);

            fallingBlocks.forEach((b, i) => {
                b.y += fallSpeed;
                
                let landY = floorY - CELL_SIZE;
                const stack = grid[b.col];
                if(stack.length > 0) landY = stack[stack.length - 1].targetY - CELL_SIZE;

                if(b.y >= landY) {
                    b.y = landY;
                    b.targetY = landY;
                    grid[b.col].push(b);
                    fallingBlocks.splice(i, 1); 
                    sfx.land();
                    shake = 1;

                    if(b.y <= DANGER_Y) {
                        isGameOver = true;
                        sfx.gameOver();
                        gameOverScreen.style.display = 'block';
                        finalScoreEl.innerText = score;
                    }
                }
            });

            grid.forEach(col => {
                col.forEach((b, r) => {
                    const desiredY = floorY - CELL_SIZE - (r * CELL_SIZE);
                    b.targetY = desiredY;
                    if (b.y < desiredY) {
                        b.y += fallSpeed * 6;
                        if(b.y > desiredY) b.y = desiredY;
                    } else {
                        b.y = desiredY;
                    }
                });
            });

            powerups.forEach((p, i) => {
                p.update(timeScale);
                if(p.y > height) powerups.splice(i, 1);
            });

            for (let i = bullets.length - 1; i >= 0; i--) {
                const bul = bullets[i];
                bul.update(timeScale);
                if (bul.dead) { bullets.splice(i, 1); continue; }

                let hit = false;
                
                for (let j = powerups.length - 1; j >= 0; j--) {
                    const p = powerups[j];
                    const dist = Math.hypot(bul.x - p.x, bul.y - p.y);
                    if (dist < p.radius + 5) {
                        activatePowerUp(p.type);
                        createExplosion(p.x, p.y, p.color);
                        powerups.splice(j, 1);
                        hit = true;
                        break;
                    }
                }

                if (hit) {
                    bullets.splice(i, 1);
                    continue;
                }

                const checkBlock = (b) => {
                    const bx = gridOffsetX + b.col * CELL_SIZE + 3;
                    return (bul.x > bx && bul.x < bx + b.w && bul.y > b.y + 3 && bul.y < b.y + b.h + 3);
                };

                for (let j = fallingBlocks.length - 1; j >= 0; j--) {
                    if (checkBlock(fallingBlocks[j])) {
                        createExplosion(bul.x, bul.y, fallingBlocks[j].color);
                        fallingBlocks.splice(j, 1);
                        hit = true;
                        addScore(20);
                        break;
                    }
                }

                if (!hit) {
                    outer: for (let c = 0; c < COLS; c++) {
                        const stack = grid[c];
                        for (let r = stack.length - 1; r >= 0; r--) {
                            if (checkBlock(stack[r])) {
                                createExplosion(bul.x, bul.y, stack[r].color);
                                stack.splice(r, 1);
                                hit = true;
                                addScore(10);
                                break outer;
                            }
                        }
                    }
                }

                if (hit) {
                    bullets.splice(i, 1);
                    sfx.hit();
                }
            }

            for(let i=particles.length-1; i>=0; i--) {
                particles[i].update(timeScale);
                if(particles[i].life <= 0) particles.splice(i, 1);
            }
        }

        function draw() {
            ctx.fillStyle = '#f4f7f6';
            ctx.fillRect(0, 0, width, height);

            const sx = (Math.random() - 0.5) * shake;
            const sy = (Math.random() - 0.5) * shake;
            ctx.save();
            ctx.translate(sx, sy);

            const gridWidth = COLS * CELL_SIZE;
            const gridOffsetX = (width - gridWidth) / 2;
            const floorY = height - GRID_BOTTOM_MARGIN;

            ctx.strokeStyle = '#e0e5e9';
            ctx.lineWidth = 1;
            for(let i=0; i<=COLS; i++) {
                const x = gridOffsetX + i * CELL_SIZE;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, floorY);
                ctx.stroke();
            }

            ctx.fillStyle = '#bdc3c7';
            ctx.fillRect(gridOffsetX - 10, floorY, gridWidth + 20, 4);

            ctx.strokeStyle = '#ff7675';
            ctx.lineWidth = 2;
            ctx.setLineDash([8, 8]);
            ctx.beginPath();
            ctx.moveTo(gridOffsetX - 20, DANGER_Y);
            ctx.lineTo(gridOffsetX + gridWidth + 20, DANGER_Y);
            ctx.stroke();
            ctx.setLineDash([]);

            grid.forEach(col => col.forEach(b => b.draw(gridOffsetX)));
            fallingBlocks.forEach(b => b.draw(gridOffsetX));
            powerups.forEach(p => p.draw());
            particles.forEach(p => p.draw());
            bullets.forEach(b => b.draw());

            drawGun();
            drawCrosshair();

            ctx.restore();
        }

        function drawGun() {
            const cx = width / 2;
            const cy = height;
            const angle = Math.atan2(mouse.y - cy, mouse.x - cx);
            const recoil = shake * 3;

            ctx.save();
            ctx.translate(cx, cy);
            ctx.rotate(angle + Math.PI/2);

            ctx.fillStyle = '#2c3e50';
            ctx.beginPath();
            ctx.roundRect(-15, -20, 30, 40, 5);
            ctx.fill();

            ctx.fillStyle = '#34495e';
            ctx.beginPath();
            if (activePowerUp?.type === 'MINIGUN') {
                ctx.roundRect(-12, -70 + recoil, 8, 60, 2);
                ctx.roundRect(4, -70 + recoil, 8, 60, 2);
                ctx.roundRect(-4, -75 + recoil, 8, 65, 2); 
                ctx.fill();
            } else {
                ctx.roundRect(-8, -70 + recoil, 16, 60, 4);
                ctx.fill();
            }

            ctx.fillStyle = activePowerUp ? UPGRADE_TYPES[activePowerUp.type].color : '#1abc9c';
            ctx.beginPath();
            ctx.arc(0, -10, 4, 0, Math.PI*2);
            ctx.fill();

            ctx.restore();
        }

        function drawCrosshair() {
            const x = mouse.x;
            const y = mouse.y;
            const color = '#2c3e50';
            ctx.lineWidth = 2;
            ctx.strokeStyle = color;
            
            ctx.beginPath();
            ctx.arc(x, y, 12, 0, Math.PI*2);
            ctx.moveTo(x - 18, y);
            ctx.lineTo(x - 5, y);
            ctx.moveTo(x + 5, y);
            ctx.lineTo(x + 18, y);
            ctx.moveTo(x, y - 18);
            ctx.lineTo(x, y - 5);
            ctx.moveTo(x, y + 5);
            ctx.lineTo(x, y + 18);
            ctx.stroke();

            if (activePowerUp?.type === 'TRIPLE') {
                 ctx.setLineDash([2, 4]);
                 ctx.beginPath();
                 ctx.moveTo(x, y);
                 ctx.lineTo(x - 20, y - 30);
                 ctx.moveTo(x, y);
                 ctx.lineTo(x + 20, y - 30);
                 ctx.stroke();
                 ctx.setLineDash([]);
            }
        }

        function loop(now) {
            update(now);
            draw();
            animationId = requestAnimationFrame(loop);
        }

        function resetGame() {
            if(animationId) cancelAnimationFrame(animationId);
            init();
        }

        init();

    </script>
</body>
</html>
