<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Block Shooter Ultimate</title>
    <style>
        :root {
            --primary: #2c3e50;
            --accent: #e74c3c;
            --bg: #f4f7f6;
            --glass: rgba(255, 255, 255, 0.85);
            --glass-border: rgba(255, 255, 255, 0.6);
            --shadow: 0 10px 40px rgba(0,0,0,0.1);
            --coin-gold: #f1c40f;
            --coin-shadow: #d35400;
        }
        body {
            margin: 0;
            overflow: hidden;
            background: var(--bg);
            font-family: 'Inter', 'Segoe UI', system-ui, sans-serif;
            user-select: none;
            touch-action: none;
            color: var(--primary);
        }
       
        /* CANVAS STYLES & BLUR TRANSITION */
        canvas {
            display: block;
            transition: filter 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }
        canvas.blurred {
            filter: blur(12px) opacity(0.9);
        }
       
        /* UI LAYOUTS */
        .screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            transition: all 0.5s cubic-bezier(0.19, 1, 0.22, 1);
            opacity: 0;
            transform: scale(1.05);
            z-index: 10;
            background: rgba(255,255,255,0.1);
        }
        .screen.active {
            opacity: 1;
            pointer-events: auto;
            transform: scale(1);
        }

        /* MENU STYLES */
        .panel {
            background: var(--glass);
            padding: 40px;
            border-radius: 32px;
            box-shadow: var(--shadow);
            text-align: center;
            max-width: 600px;
            width: 90%;
            backdrop-filter: blur(25px);
            -webkit-backdrop-filter: blur(25px);
            border: 1px solid var(--glass-border);
            max-height: 85vh;
            overflow-y: auto;
        }
        h1 { margin: 0 0 10px 0; font-size: 42px; letter-spacing: -2px; color: var(--primary); }
        h2 { margin: 0 0 20px 0; font-size: 24px; color: #7f8c8d; font-weight: 500; letter-spacing: -0.5px; }
        .stat-row { display: flex; justify-content: space-around; margin: 25px 0; width: 100%; }
        .stat { font-weight: 800; font-size: 28px; color: var(--primary); }
        .stat span { display: block; font-size: 11px; color: #95a5a6; font-weight: 700; text-transform: uppercase; margin-top: 5px; letter-spacing: 1px;}

        button {
            background: var(--primary);
            border: none;
            color: white;
            padding: 18px 45px;
            font-size: 18px;
            font-weight: 700;
            cursor: pointer;
            border-radius: 16px;
            margin: 10px;
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            box-shadow: 0 4px 15px rgba(44, 62, 80, 0.2);
            position: relative;
            overflow: hidden;
        }
        button:hover { transform: translateY(-4px) scale(1.02); box-shadow: 0 12px 30px rgba(44, 62, 80, 0.3); background: #34495e; }
        button:active { transform: scale(0.96); }
        button.secondary { background: #ecf0f1; color: var(--primary); }
        button.secondary:hover { background: #bdc3c7; }
        button.accent { background: #e67e22; color: white; }
        button.accent:hover { background: #d35400; }
        button:disabled { opacity: 0.5; cursor: not-allowed; transform: none; box-shadow: none; }
       
        /* MUSIC TOGGLE */
        #music-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(255,255,255,0.8);
            backdrop-filter: blur(5px);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 100;
            font-size: 20px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            transition: all 0.2s;
            pointer-events: auto;
        }
        #music-toggle:hover { transform: scale(1.1); }
        #music-toggle.playing { background: #2ecc71; color: white; }

        /* LEADERBOARD TABLE */
        .leaderboard-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            font-size: 14px;
        }
        .leaderboard-table th { text-align: left; color: #95a5a6; font-size: 10px; text-transform: uppercase; padding-bottom: 10px; border-bottom: 2px solid #eee; }
        .leaderboard-table td { padding: 12px 0; border-bottom: 1px solid #f0f0f0; font-weight: 600; }
        .leaderboard-table tr:first-child td { color: #f39c12; font-weight: 800; font-size: 16px; }
        .rank-cell { width: 40px; color: #bdc3c7; }

        /* INPUT FIELD */
        .name-input {
            background: #fff;
            border: 2px solid #e0e0e0;
            padding: 15px;
            border-radius: 12px;
            font-size: 18px;
            font-weight: bold;
            width: 70%;
            text-align: center;
            margin-bottom: 10px;
            font-family: inherit;
            outline: none;
            transition: border-color 0.3s;
        }
        .name-input:focus { border-color: var(--primary); }

        /* MENU INPUT */
        .menu-input {
            background: rgba(255,255,255,0.9);
            border: 2px solid #bdc3c7;
            padding: 12px;
            border-radius: 12px;
            font-size: 16px;
            font-weight: bold;
            width: 60%;
            text-align: center;
            margin: 15px 0;
            font-family: inherit;
            outline: none;
            transition: all 0.3s;
            color: var(--primary);
            text-transform: uppercase;
        }
        .menu-input:focus { border-color: var(--primary); box-shadow: 0 0 15px rgba(44, 62, 80, 0.1); transform: scale(1.05); }

        /* COIN ICON */
        .coin-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 24px; height: 24px;
            background: radial-gradient(circle at 30% 30%, #f1c40f, #f39c12);
            border-radius: 50%;
            border: 2px solid #e67e22;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            font-size: 14px;
            font-weight: bold;
            color: #d35400;
            position: relative;
        }
        .coin-icon::after {
            content: '$';
            position: relative;
            top: -1px;
        }

        /* HUD */
        #ui-hud {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: none;
            flex-direction: column;
            justify-content: space-between;
            box-sizing: border-box;
            background: none;
        }
        .hud-content {
            padding: 30px;
            display: flex;
            flex-direction: column;
            height: 100%;
            justify-content: space-between;
        }
        .hud-top { display: flex; justify-content: space-between; align-items: flex-start; }
       
        .score-block {
            text-align: left;
            background: rgba(255, 255, 255, 0.75);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            padding: 15px 25px;
            border-radius: 24px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.05);
            border: 1px solid rgba(255,255,255,0.8);
        }
       
        .score-val { font-size: 42px; font-weight: 800; line-height: 1; letter-spacing: -1.5px; color: var(--primary); }
        .score-label { font-size: 12px; color: #7f8c8d; font-weight: 800; text-transform: uppercase; margin-bottom: 2px; letter-spacing: 0.5px; }
        .coin-display {
            font-size: 20px; font-weight: 700; color: #f39c12;
            text-shadow: 0 2px 5px rgba(243, 156, 18, 0.1);
            display: flex; align-items: center; gap: 8px; margin-top: 5px;
        }
       
        /* POWERUP STACK UI */
        #active-effects {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 20px;
            align-items: flex-start;
        }
        .effect-tag {
            background: var(--primary);
            color: white;
            padding: 8px 14px;
            border-radius: 8px;
            font-size: 11px;
            font-weight: 800;
            text-transform: uppercase;
            box-shadow: 0 4px 15px rgba(0,0,0,0.15);
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            display: flex; align-items: center; gap: 6px;
        }
        .pulse-text { animation: pulse 2s infinite ease-in-out; }
        @keyframes pulse { 0%, 100% { opacity: 0.6; transform: scale(0.98); } 50% { opacity: 1; transform: scale(1); } }
        @keyframes popIn { from { transform: scale(0); } to { transform: scale(1); } }

        /* EXIT BTN */
        #btn-exit {
            pointer-events: auto;
            background: rgba(255,255,255,0.75);
            width: 48px; height: 48px;
            border-radius: 24px;
            display: flex; align-items: center; justify-content: center;
            font-weight: 900;
            font-size: 22px;
            cursor: pointer;
            box-shadow: 0 8px 32px rgba(0,0,0,0.05);
            transition: all 0.2s ease;
            color: #e74c3c;
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255,255,255,0.8);
        }
        #btn-exit:hover { transform: scale(1.1) rotate(90deg); box-shadow: 0 10px 30px rgba(0,0,0,0.1); }

        /* SHOP UI */
        .shop-nav {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 15px;
            border-bottom: 2px solid rgba(0,0,0,0.05);
            padding-bottom: 15px;
        }
        .shop-tab {
            background: transparent;
            color: #7f8c8d;
            box-shadow: none;
            padding: 8px 16px;
            margin: 0;
            font-size: 14px;
            border-radius: 8px;
        }
        .shop-tab:hover { transform: none; background: rgba(0,0,0,0.05); }
        .shop-tab.active { background: var(--primary); color: white; box-shadow: 0 4px 10px rgba(44, 62, 80, 0.2); }

        .shop-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin: 10px 0 25px 0;
            max-height: 350px;
            overflow-y: auto;
            text-align: left;
            padding: 5px;
        }
        .shop-item {
            background: white;
            padding: 20px;
            border-radius: 20px;
            border: 2px solid transparent;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            box-shadow: 0 5px 15px rgba(0,0,0,0.03);
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        .shop-item:hover { border-color: #bdc3c7; transform: translateY(-3px); box-shadow: 0 10px 25px rgba(0,0,0,0.08); }
        .shop-item.locked { opacity: 0.6; filter: grayscale(1); pointer-events: none; }
        .shop-item.equipped { border-color: #2ecc71; background: #f0fdf4; }
       
        .shop-item h3 { margin: 0; font-size: 16px; font-weight: 800; }
        .shop-item p { margin: 6px 0 12px 0; font-size: 12px; color: #95a5a6; line-height: 1.4; }
        .shop-price { font-weight: 800; color: #f39c12; font-size: 14px; display: flex; align-items: center; gap: 5px;}
        .shop-lvl { position: absolute; top: 15px; right: 15px; font-size: 10px; font-weight: 800; background: #f4f7f6; padding: 4px 8px; border-radius: 6px; color: #7f8c8d; }
        .shop-action { font-size: 10px; font-weight: 900; text-transform: uppercase; padding: 4px 8px; border-radius: 4px; background: #ecf0f1; color: #7f8c8d; align-self: flex-start;}
        .equipped .shop-action { background: #2ecc71; color: white; }

        /* ADMIN PANEL */
        #admin-panel {
            position: absolute;
            top: 100px; left: 50px;
            width: 280px;
            background: rgba(255, 255, 255, 0.95);
            color: #2c3e50;
            font-family: 'Inter', sans-serif;
            padding: 0;
            border-radius: 20px;
            display: none;
            box-shadow: 0 20px 60px rgba(0,0,0,0.2);
            z-index: 1000;
            user-select: none;
            border: 1px solid rgba(255,255,255,0.8);
            backdrop-filter: blur(15px);
            overflow: hidden;
            animation: slideUp 0.3s ease;
        }
        @keyframes slideUp { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
       
        #admin-header {
            background: #ecf0f1;
            padding: 15px 20px;
            cursor: move;
            font-weight: 800;
            font-size: 13px;
            letter-spacing: 1px;
            text-transform: uppercase;
            display: flex;
            justify-content: space-between;
            color: #7f8c8d;
            border-bottom: 1px solid #e0e0e0;
        }
        #admin-content { padding: 20px; }
        .admin-row { margin-bottom: 15px; display: flex; justify-content: space-between; align-items: center; font-size: 14px; font-weight: 600;}
        .admin-btn {
            background: #2c3e50; border: none; color: white; border-radius: 8px;
            padding: 8px 16px; cursor: pointer; font-size: 11px; font-weight: 700;
            transition: all 0.2s;
        }
        .admin-btn:hover { background: #34495e; transform: scale(1.05); }
        .admin-input {
            width: 80px; background: #f4f7f6; border: 2px solid #e0e0e0; color: #2c3e50;
            border-radius: 8px; padding: 6px; font-weight: bold; text-align: center; font-family: inherit;
        }
        .admin-input:focus { border-color: #3498db; outline: none; }
       
        /* CHECKBOX CUSTOM */
        .toggle-switch { position: relative; width: 40px; height: 20px; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 20px; }
        .slider:before { position: absolute; content: ""; height: 16px; width: 16px; left: 2px; bottom: 2px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #2ecc71; }
        input:checked + .slider:before { transform: translateX(20px); }

        /* SCROLLBAR */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #bdc3c7; border-radius: 3px; }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <!-- MUSIC TOGGLE -->
    <div id="music-toggle" onclick="Music.toggle()">♫</div>

    <!-- ADMIN PANEL -->
    <div id="admin-panel">
        <div id="admin-header">
            <span>Dev Console</span>
            <span style="cursor:pointer; font-size: 16px;" onclick="toggleAdmin()">×</span>
        </div>
        <div id="admin-content">
            <div class="admin-row">
                <span>Infinite Funds</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="chk-inf-money">
                    <span class="slider"></span>
                </label>
            </div>
            <div class="admin-row">
                <input type="number" id="inp-money" class="admin-input" value="1000">
                <button class="admin-btn" onclick="adminAddMoney()">ADD CASH</button>
            </div>
            <div class="admin-row">
                <button class="admin-btn" style="width: 48%; background:#e74c3c" onclick="adminSetMoney(0)">RESET</button>
                <button class="admin-btn" style="width: 48%; background:#f1c40f; color: #d35400" onclick="adminSetMoney(99999)">MAX</button>
            </div>
        </div>
    </div>

    <!-- MAIN MENU -->
    <div id="screen-menu" class="screen active">
        <div class="panel">
            <h1>BLOCK SHOOTER</h1>
            <div class="stat-row">
                <div class="stat"><span id="menu-score">0</span><span>BEST SCORE</span></div>
                <div class="stat"><span id="menu-coins">0</span><span>BANK</span></div>
            </div>
           
            <input type="text" id="menu-user" class="menu-input" placeholder="ENTER AGENT NAME" maxlength="12" oninput="Data.updateName(this.value)">

            <button onclick="Game.start()">PLAY GAME</button>
            <button class="secondary" onclick="UI.showShop()">UPGRADE SHOP</button>
            <button class="secondary" onclick="UI.showLeaderboard()">LEADERBOARD</button>
        </div>
    </div>

    <!-- SHOP -->
    <div id="screen-shop" class="screen">
        <div class="panel" style="max-width: 600px;">
            <div class="coin-display" style="justify-content:center; margin-bottom:10px;">
                <div class="coin-icon"></div> <span id="shop-coins">0</span>
            </div>
           
            <div class="shop-nav">
                <button class="shop-tab active" onclick="UI.setShopTab('upgrades')">Upgrades</button>
                <button class="shop-tab" onclick="UI.setShopTab('arsenal')">Arsenal</button>
                <button class="shop-tab" onclick="UI.setShopTab('themes')">Themes</button>
            </div>

            <div class="shop-grid" id="shop-container">
                <!-- Items injected by JS -->
            </div>
            <button class="secondary" onclick="UI.showMenu()">BACK TO MENU</button>
        </div>
    </div>

    <!-- LEADERBOARD -->
    <div id="screen-leaderboard" class="screen">
        <div class="panel" style="max-width: 500px;">
            <h2>GLOBAL RANKING</h2>
            <div style="max-height: 300px; overflow-y: auto;">
                <table class="leaderboard-table">
                    <thead>
                        <tr>
                            <th style="padding-left:10px">#</th>
                            <th>AGENT</th>
                            <th style="text-align:right; padding-right:10px">SCORE</th>
                        </tr>
                    </thead>
                    <tbody id="lb-body">
                        <!-- Filled by JS -->
                        <tr><td colspan="3">Connecting to mainframe...</td></tr>
                    </tbody>
                </table>
            </div>
            <button class="secondary" onclick="UI.showMenu()">BACK TO MENU</button>
        </div>
    </div>

    <!-- HUD -->
    <div id="ui-hud">
        <div class="hud-content">
            <div class="hud-top">
                <div class="score-block">
                    <div class="score-label">Current Score</div>
                    <div class="score-val" id="hud-score">0</div>
                    <div class="coin-display"><div class="coin-icon"></div> <span id="hud-coins">0</span></div>
                    <div id="active-effects"></div>
                </div>
                <div id="btn-exit" onclick="Game.end()">✕</div>
            </div>
            <div class="score-label pulse-text" style="text-align: center; width: 100%;">TAP TO SHOOT</div>
        </div>
    </div>

    <!-- GAME OVER -->
    <div id="screen-gameover" class="screen">
        <div class="panel">
            <h1>SYSTEM CRITICAL</h1>
            <p>Grid capacity exceeded.</p>
            <div class="stat-row">
                <div class="stat"><span id="go-score">0</span><span>SCORE</span></div>
                <div class="stat"><span id="go-coins">0</span><span>EARNED</span></div>
            </div>
           
            <div id="submit-msg" style="margin-bottom: 20px; font-weight: bold; color: #2ecc71; min-height: 20px;">
                SYNCING TO MAINFRAME...
            </div>

            <button onclick="Game.start()">RETRY MISSION</button>
            <button class="secondary" onclick="UI.showMenu()">MAIN MENU</button>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/11.0.2/firebase-app.js';
        import { getAuth, signInAnonymously, signInWithCustomToken } from 'https://www.gstatic.com/firebasejs/11.0.2/firebase-auth.js';
        import { getFirestore, collection, doc, setDoc, getDocs, query, orderBy, limit } from 'https://www.gstatic.com/firebasejs/11.0.2/firebase-firestore.js';

        // --- FIREBASE CONFIG ---
        let app, auth, db;
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'block-shooter';

        try {
            // Check if environment provides config (Canvas), otherwise handle gracefully (GitHub/Local)
            if (typeof __firebase_config !== 'undefined') {
                const firebaseConfig = JSON.parse(__firebase_config);
                app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getFirestore(app);
            } else {
                console.warn("Firebase configuration not found. Game running in offline mode (Leaderboard disabled).");
                // To make leaderboard work on GitHub, replace the if block above with your own config:
                // const firebaseConfig = { apiKey: "...", authDomain: "...", projectId: "..." };
                // app = initializeApp(firebaseConfig); auth = getAuth(app); db = getFirestore(app);
            }
        } catch(e) {
            console.warn("Firebase initialization skipped:", e);
        }

        // --- AUTH & LEADERBOARD MODULE ---
        const Leaderboard = {
            user: null,
            async init() {
                if (!auth) return; // Offline mode
                try {
                    // Try custom token first (required for some environments), then fallback to anonymous
                    if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                        const cred = await signInWithCustomToken(auth, __initial_auth_token);
                        this.user = cred.user;
                    } else {
                        const cred = await signInAnonymously(auth);
                        this.user = cred.user;
                    }
                    console.log("Auth success", this.user.uid);
                } catch (e) {
                    console.error("Auth failed", e);
                }
            },
            async submitScore(name, score) {
                if (!auth || !db) return false; // Offline mode

                // If auth hasn't finished yet, try one more time or wait
                if (!this.user) {
                    await this.init();
                    if (!this.user) return false;
                }
               
                if (!name || name.trim() === "") name = "Unknown Agent";
               
                try {
                    // Use User UID as the Document ID to ensure 1 entry per user that gets overridden
                    const scoresRef = collection(db, 'artifacts', appId, 'public', 'data', 'leaderboard');
                    await setDoc(doc(scoresRef, this.user.uid), {
                        name: name.toUpperCase(),
                        score: score,
                        timestamp: Date.now(),
                        uid: this.user.uid
                    }, { merge: true }); // Merge ensures we update the existing doc
                    return true;
                } catch (e) {
                    console.error("Score submit error", e);
                    return false;
                }
            },
            async fetchTop10() {
                if (!auth || !db) return []; // Offline mode

                if (!this.user) {
                     await this.init();
                     if (!this.user && auth.currentUser) this.user = auth.currentUser;
                }
               
                const scoresRef = collection(db, 'artifacts', appId, 'public', 'data', 'leaderboard');
                try {
                    const q = query(scoresRef);
                    const snapshot = await getDocs(q);
                    let scores = [];
                    snapshot.forEach(doc => scores.push(doc.data()));
                    scores.sort((a,b) => b.score - a.score);
                    return scores.slice(0, 10);
                } catch (e) {
                    console.error("Fetch error", e);
                    return [];
                }
            }
        };

        // --- MUSIC ENGINE (PROCEDURAL) ---
        const Music = {
            ctx: null,
            isPlaying: false,
            bpm: 110,
            nextNoteTime: 0,
            beat: 0,
            lookahead: 25.0,
            scheduleAheadTime: 0.1,
            timerID: null,
           
            // SYNTHWAVE SCALES (D Minor Natural)
            bassLine: [36.71, 36.71, 36.71, 36.71, 43.65, 43.65, 32.70, 48.99], // D1, F1, C1, G1
            arp: [293.66, 349.23, 440.00, 523.25], // D4, F4, A4, C5

            toggle() {
                this.isPlaying = !this.isPlaying;
                const btn = document.getElementById('music-toggle');
               
                if(this.isPlaying) {
                    if(!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    if(this.ctx.state === 'suspended') this.ctx.resume();
                    this.nextNoteTime = this.ctx.currentTime;
                    this.scheduler();
                    btn.classList.add('playing');
                } else {
                    window.clearTimeout(this.timerID);
                    btn.classList.remove('playing');
                }
            },

            scheduler() {
                while (this.nextNoteTime < this.ctx.currentTime + this.scheduleAheadTime) {
                    this.scheduleNote(this.beat, this.nextNoteTime);
                    this.nextBeat();
                }
                this.timerID = window.setTimeout(() => this.scheduler(), this.lookahead);
            },

            nextBeat() {
                const secondsPerBeat = 60.0 / this.bpm;
                this.nextNoteTime += 0.25 * secondsPerBeat; // 16th notes
                this.beat = (this.beat + 1) % 16; // 16 steps loop
            },

            scheduleNote(beatNumber, time) {
                // DRUMS
                if (beatNumber % 4 === 0) this.playKick(time);
                if (beatNumber % 8 === 4) this.playSnare(time);
                if (beatNumber % 2 === 0) this.playHat(time);

                // BASS (8th notes)
                if (beatNumber % 2 === 0) {
                    const noteIdx = Math.floor(beatNumber / 2) % 8; // 8 notes in bass loop
                    // Wrap index to bassLine length
                    const freq = this.bassLine[Math.floor(Date.now() / 4000) % this.bassLine.length];
                    this.playBass(time, freq);
                }

                // ARP (16th notes - running)
                if (beatNumber % 1 === 0) {
                   const freq = this.arp[beatNumber % 4];
                   // Probabilistic Lead
                   if(Math.random() > 0.3) this.playLead(time, freq);
                }
            },

            playKick(time) {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.frequency.setValueAtTime(150, time);
                osc.frequency.exponentialRampToValueAtTime(0.01, time + 0.5);
                gain.gain.setValueAtTime(1, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.5);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start(time);
                osc.stop(time + 0.5);
            },
            playSnare(time) {
                const bufferSize = this.ctx.sampleRate * 0.5; // 0.5s noise
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
               
                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.value = 1000;
                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0.5, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.2);
               
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);
                noise.start(time);
            },
            playHat(time) {
                const osc = this.ctx.createOscillator(); // Simple tone hat for retro feel
                const gain = this.ctx.createGain();
                osc.type = 'square';
                osc.frequency.value = 8000;
                filter: {
                    const f = this.ctx.createBiquadFilter();
                    f.type = 'highpass';
                    f.frequency.value = 7000;
                    osc.connect(f);
                    f.connect(gain);
                }
                gain.gain.setValueAtTime(0.1, time);
                gain.gain.exponentialRampToValueAtTime(0.001, time + 0.05);
                gain.connect(this.ctx.destination);
                osc.start(time);
                osc.stop(time + 0.05);
            },
            playBass(time, freq) {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();
               
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(freq, time);
               
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(400, time);
                filter.frequency.exponentialRampToValueAtTime(100, time + 0.3); // filter envelope

                gain.gain.setValueAtTime(0.4, time);
                gain.gain.linearRampToValueAtTime(0, time + 0.3);

                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start(time);
                osc.stop(time + 0.3);
            },
            playLead(time, freq) {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();
               
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(freq, time);
               
                filter.type = 'lowpass';
                filter.frequency.value = 1500;
               
                gain.gain.setValueAtTime(0.05, time);
                gain.gain.exponentialRampToValueAtTime(0.001, time + 0.15);

                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start(time);
                osc.stop(time + 0.2);
            }
        };

        // --- CONSTANTS & CONFIG ---
        const CONFIG = {
            COLS: 8,
            GRID_MARGIN_BOTTOM: 140,
            DANGER_Y: 120,
            DEFAULT_FIRE_RATE: 200,
            MINIGUN_FIRE_RATE: 70,
            STORAGE_KEY: 'block_buster_v6'
        };

        const UPGRADES = {
            // Category: Upgrades (Passive)
            luck: { category: 'upgrades', name: "Freq Module", desc: "Spawn more power-ups", cost: 100, max: 10, type: 'passive' },
            rate: { category: 'upgrades', name: "Overclock", desc: "Faster Minigun speed", cost: 150, max: 5, type: 'passive' },
            greed: { category: 'upgrades', name: "Coin Fabricator", desc: "+10% Coin Value", cost: 200, max: 10, type: 'passive' },
            adrenaline: { category: 'upgrades', name: "Adrenaline", desc: "Faster Spawns (More $$)", cost: 1000, max: 5, type: 'passive' },
           
            // Category: Arsenal (Unlocks)
            unlock_bomb: { category: 'arsenal', name: "Unlock: BOMB", desc: "Explosive rounds", cost: 500, max: 1, type: 'unlock' },
            unlock_laser: { category: 'arsenal', name: "Unlock: LASER", desc: "Piercing beam", cost: 750, max: 1, type: 'unlock' },
            unlock_nuke: { category: 'arsenal', name: "Unlock: NUKE", desc: "Screen clear", cost: 2000, max: 1, type: 'unlock' },

            // Category: Themes (Backgrounds)
            bg_clean: { category: 'themes', name: "Clean", desc: "Standard sterile environment", cost: 0, type: 'background' },
            bg_vapor: { category: 'themes', name: "Vaporwave", desc: "Retro synth grid & sun", cost: 1500, type: 'background' },
            bg_midnight: { category: 'themes', name: "Midnight", desc: "Deep space starlight", cost: 2500, type: 'background' },
            bg_emerald: { category: 'themes', name: "Emerald", desc: "Misty forest layers", cost: 3500, type: 'background' }
        };

        const POWERUPS = {
            TRIPLE: { name: 'Triple Shot', color: '#e67e22', duration: 5000 },
            MINIGUN: { name: 'Minigun', color: '#e74c3c', duration: 4000 },
            BOMB: { name: 'Bomb Shot', color: '#2c3e50', duration: 1 },
            LASER: { name: 'Laser Beam', color: '#8e44ad', duration: 3000 },
            NUKE: { name: 'Nuke', color: '#f1c40f', duration: 0 }
        };

        // --- AUDIO ENGINE ---
        const Audio = {
            ctx: null,
            play(freq, type, dur, vol = 0.1) {
                if(!this.ctx) this.ctx = Music.ctx || new (window.AudioContext || window.webkitAudioContext)();
                if (this.ctx.state === 'suspended') this.ctx.resume();
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + dur);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + dur);
            },
            sfx: {
                shoot: () => {
                    if(!Audio.ctx) Audio.ctx = Music.ctx || new (window.AudioContext || window.webkitAudioContext)();
                    const t = Audio.ctx.currentTime;
                    const o = Audio.ctx.createOscillator();
                    const g = Audio.ctx.createGain();
                    o.frequency.setValueAtTime(600, t);
                    o.frequency.exponentialRampToValueAtTime(100, t + 0.1);
                    g.gain.setValueAtTime(0.05, t);
                    g.gain.linearRampToValueAtTime(0, t + 0.1);
                    o.connect(g);
                    g.connect(Audio.ctx.destination);
                    o.start();
                    o.stop(t + 0.1);
                },
                hit: () => Audio.play(200, 'sine', 0.1, 0.1),
                bossHit: () => { Audio.play(150, 'sawtooth', 0.1, 0.15); },
                coin: () => { Audio.play(1200, 'square', 0.1, 0.05); setTimeout(() => Audio.play(1600, 'square', 0.1, 0.05), 50); },
                powerup: () => Audio.play(600, 'sine', 0.3, 0.1),
                explode: () => Audio.play(100, 'sawtooth', 0.4, 0.2),
                laser: () => Audio.play(800, 'sawtooth', 0.2, 0.05)
            }
        };

        // --- DATA LAYER ---
        const Data = {
            profile: {
                username: "Agent",
                coins: 0,
                highScore: 0,
                upgrades: { luck: 0, rate: 0, greed: 0, adrenaline: 0, unlock_bomb: 0, unlock_laser: 0, unlock_nuke: 0 },
                inventory: ['bg_clean'],
                equippedBg: 'bg_clean'
            },
            save() {
                localStorage.setItem(CONFIG.STORAGE_KEY, JSON.stringify(this.profile));
                UI.updateMenuStats();
            },
            load() {
                const saved = localStorage.getItem(CONFIG.STORAGE_KEY);
                if (saved) {
                    const parsed = JSON.parse(saved);
                    this.profile = { ...this.profile, ...parsed };
                    if (!this.profile.inventory) this.profile.inventory = ['bg_clean'];
                    if (!this.profile.equippedBg) this.profile.equippedBg = 'bg_clean';
                    if (!this.profile.username) this.profile.username = "Agent";
                }
               
                // Initialize Menu Input
                const inp = document.getElementById('menu-user');
                if(inp) inp.value = this.profile.username;
               
                UI.updateMenuStats();
            },
            updateName(val) {
                this.profile.username = val.toUpperCase();
                this.save();
            },
            canBuy(key) {
                const upg = UPGRADES[key];
                if (upg.type === 'background') {
                    return !this.profile.inventory.includes(key) && this.profile.coins >= upg.cost;
                }
                const lvl = this.profile.upgrades[key];
                const price = Math.floor(upg.cost * Math.pow(1.5, lvl));
                return lvl < upg.max && this.profile.coins >= price;
            },
            buy(key) {
                if (!this.canBuy(key)) return;
                const upg = UPGRADES[key];
               
                if (upg.type === 'background') {
                    this.profile.coins -= upg.cost;
                    this.profile.inventory.push(key);
                    this.profile.equippedBg = key;
                } else {
                    const lvl = this.profile.upgrades[key];
                    const price = Math.floor(upg.cost * Math.pow(1.5, lvl));
                    this.profile.coins -= price;
                    this.profile.upgrades[key]++;
                }
                this.save();
                UI.renderShop();
            },
            equip(key) {
                if (this.profile.inventory.includes(key)) {
                    this.profile.equippedBg = key;
                    this.save();
                    UI.renderShop();
                }
            }
        };

        // --- GAME ENGINE ---
        const Game = {
            canvas: document.getElementById('gameCanvas'),
            ctx: document.getElementById('gameCanvas').getContext('2d'),
            width: 0, height: 0,
            loopId: null,
            lastTime: 0,
            state: 'MENU',
           
            // Session State
            score: 0,
            sessionCoins: 0,
            grid: [],
            entities: { blocks: [], bullets: [], particles: [], powerups: [], stars: [] },
            activeEffects: new Map(),
            timers: { spawn: 0, shot: 0 },
            mouse: { x: 0, y: 0, down: false },
            blocksSpawnedCount: 0,
           
            // Animation States
            shake: 0,
            gunRecoil: 0,
            muzzleFlash: 0,

            // Admin Cheats
            infiniteMoney: false,

            init() {
                this.resize();
                window.addEventListener('resize', () => this.resize());
                this.setupInput();
                Data.load();
                Leaderboard.init();
                this.initStars();
               
                // Admin Drag
                const adminPanel = document.getElementById('admin-panel');
                const adminHeader = document.getElementById('admin-header');
                let isDragging = false;
                let offset = {x:0, y:0};

                adminHeader.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    offset.x = e.clientX - adminPanel.offsetLeft;
                    offset.y = e.clientY - adminPanel.offsetTop;
                });
                window.addEventListener('mousemove', (e) => {
                    if(isDragging) {
                        adminPanel.style.left = (e.clientX - offset.x) + 'px';
                        adminPanel.style.top = (e.clientY - offset.y) + 'px';
                    }
                });
                window.addEventListener('mouseup', () => isDragging = false);
            },

            initStars() {
                this.entities.stars = [];
                for(let i=0; i<100; i++) {
                    this.entities.stars.push({
                        x: Math.random() * window.innerWidth,
                        y: Math.random() * window.innerHeight,
                        size: Math.random() * 2,
                        alpha: Math.random()
                    });
                }
            },

            resize() {
                this.width = this.canvas.width = window.innerWidth;
                this.height = this.canvas.height = window.innerHeight;
                this.cellSize = Math.floor(Math.min(550, this.width - 20) / CONFIG.COLS);
                this.gridOffsetX = (this.width - (CONFIG.COLS * this.cellSize)) / 2;
                this.initStars();
            },

            setupInput() {
                const move = (x, y) => { this.mouse.x = x; this.mouse.y = y; };
                window.addEventListener('mousemove', e => move(e.clientX, e.clientY));
                window.addEventListener('touchmove', e => { e.preventDefault(); move(e.touches[0].clientX, e.touches[0].clientY); }, {passive:false});
               
                const down = () => { this.mouse.down = true; if(this.state === 'PLAYING') this.tryShoot(); };
                window.addEventListener('mousedown', down);
                this.canvas.addEventListener('touchstart', (e) => { down(); move(e.touches[0].clientX, e.touches[0].clientY); }, {passive:false});
               
                window.addEventListener('mouseup', () => this.mouse.down = false);
                window.addEventListener('touchend', () => this.mouse.down = false);

                let buffer = "";
                window.addEventListener('keydown', (e) => {
                    if(e.key.length === 1) {
                        buffer += e.key.toLowerCase();
                        if (buffer.length > 20) buffer = buffer.slice(-20);
                        if (buffer.endsWith("haxxor")) toggleAdmin();
                    }
                });
            },

            start() {
                this.state = 'PLAYING';
                this.score = 0;
                this.sessionCoins = 0;
                this.blocksSpawnedCount = 0;
                this.grid = Array(CONFIG.COLS).fill(null).map(() => []);
                this.entities.blocks = [];
                this.entities.bullets = [];
                this.entities.particles = [];
                this.entities.powerups = [];
                this.activeEffects.clear();
                this.spawnBlock();
               
                UI.hideScreens();
                document.getElementById('ui-hud').style.display = 'flex';
                this.canvas.classList.remove('blurred');
               
                UI.updateHUD();

                this.lastTime = performance.now();
                if(this.loopId) cancelAnimationFrame(this.loopId);
                this.loopId = requestAnimationFrame(t => this.loop(t));
            },

            end() {
                this.state = 'GAMEOVER';
                Data.profile.coins += this.sessionCoins;
               
                // Update local high score
                let newHigh = false;
                if(this.score > Data.profile.highScore) {
                    Data.profile.highScore = this.score;
                    newHigh = true;
                }
                Data.save();
               
                document.getElementById('ui-hud').style.display = 'none';
                document.getElementById('go-score').innerText = this.score;
                document.getElementById('go-coins').innerText = this.sessionCoins;
               
                const msg = document.getElementById('submit-msg');
                msg.style.color = '#f39c12';
                msg.innerText = "SYNCING SCORE...";

                this.canvas.classList.add('blurred');
                document.getElementById('screen-gameover').classList.add('active');

                // AUTOMATIC SUBMISSION (Override with best score)
                Leaderboard.submitScore(Data.profile.username, Data.profile.highScore).then(success => {
                    if(success) {
                        msg.style.color = '#2ecc71';
                        msg.innerText = newHigh ? "NEW HIGH SCORE RECORDED!" : "LEADERBOARD UPDATED";
                    } else {
                        msg.style.color = '#e74c3c';
                        msg.innerText = "CONNECTION FAILED";
                    }
                });
            },

            spawnBlock() {
                this.blocksSpawnedCount++;
                const isBoss = (this.blocksSpawnedCount % 10 === 0);
               
                if (isBoss) {
                    // Spawn 2x2 Boss Block
                    const col = Math.floor(Math.random() * (CONFIG.COLS - 1)); // -1 to ensure room for width 2
                    this.entities.blocks.push({
                        type: 'BOSS',
                        col: col,
                        x: 0,
                        y: -this.cellSize * 2,
                        w: (this.cellSize * 2) - 6,
                        h: (this.cellSize * 2) - 6,
                        color: '#2c3e50',
                        hp: 15, maxHp: 15,
                        targetY: null,
                        active: true
                    });
                } else {
                    // Normal Block
                    const col = Math.floor(Math.random() * CONFIG.COLS);
                    const color = ['#3498db', '#2ecc71', '#9b59b6', '#f1c40f', '#e67e22', '#1abc9c'][Math.floor(Math.random()*6)];
                    this.entities.blocks.push({
                        type: 'NORMAL',
                        col: col,
                        x: 0,
                        y: -this.cellSize,
                        w: this.cellSize-6,
                        h: this.cellSize-6,
                        color: color,
                        targetY: null,
                        active: true
                    });
                }

                // Powerups
                const baseChance = 0.05;
                const luckBonus = Data.profile.upgrades.luck * 0.01;
               
                if (Math.random() < (baseChance + luckBonus)) {
                    const pool = ['TRIPLE', 'MINIGUN'];
                    if (Data.profile.upgrades.unlock_bomb) pool.push('BOMB');
                    if (Data.profile.upgrades.unlock_laser) pool.push('LASER');
                    if (Data.profile.upgrades.unlock_nuke) pool.push('NUKE');
                   
                    const type = pool[Math.floor(Math.random() * pool.length)];
                    this.entities.powerups.push({
                        x: Math.random() * (this.width - 60) + 30,
                        y: -50,
                        type,
                        vy: Math.random() + 1
                    });
                }
            },

            tryShoot() {
                if (!this.activeEffects.has('MINIGUN')) {
                    this.fireWeapon();
                }
            },

            fireWeapon() {
                const cx = this.width / 2;
                const cy = this.height;
                const angle = Math.atan2(this.mouse.y - cy, this.mouse.x - cx);
                const barrelLen = 70;
               
                const tipX = cx + Math.cos(angle) * barrelLen;
                const tipY = cy + Math.sin(angle) * barrelLen;

                const isTriple = this.activeEffects.has('TRIPLE');
                const isLaser = this.activeEffects.has('LASER');
                const isBomb = this.activeEffects.has('BOMB');

                this.gunRecoil = 25;
                this.muzzleFlash = 3;
                Audio.sfx.shoot();

                if (isLaser) {
                    this.entities.bullets.push({
                        type: 'LASER', x: tipX, y: tipY, angle: angle, life: 0.2, color: '#8e44ad'
                    });
                    Audio.sfx.laser();
                    this.shake = 5;
                    this.resolveLaserHit(tipX, tipY, angle);
                } else {
                    const createBullet = (angOffset) => {
                        const finalAngle = angle + angOffset;
                        const speed = 25;
                        this.entities.bullets.push({
                            type: isBomb ? 'BOMB' : 'NORMAL',
                            x: tipX,
                            y: tipY,
                            vx: Math.cos(finalAngle) * speed,
                            vy: Math.sin(finalAngle) * speed,
                            dead: false,
                            color: isBomb ? '#e74c3c' : '#2c3e50'
                        });
                    };

                    createBullet(0);
                    if (isTriple) {
                        createBullet(-0.15);
                        createBullet(0.15);
                    }
                    this.shake = 3;
                }
            },

            resolveLaserHit(x, y, angle) {
                const step = 20;
                let curX = x;
                let curY = y;
               
                while (curX > 0 && curX < this.width && curY > 0 && curY < this.height) {
                    curX += Math.cos(angle) * step;
                    curY += Math.sin(angle) * step;
                   
                    const checkPoint = (bx, by, w, h) => {
                        return (curX > bx && curX < bx + w && curY > by && curY < by + h);
                    }

                    for(let i=this.entities.blocks.length-1; i>=0; i--) {
                        const b = this.entities.blocks[i];
                        const bx = this.gridOffsetX + b.col * this.cellSize;
                        if (checkPoint(bx, b.y, b.w, b.h)) { // Use block's actual width/height
                            this.handleBulletHit({type:'LASER'}, b, 'falling', i);
                        }
                    }
                    for (let c=0; c<CONFIG.COLS; c++) {
                        for (let r=this.grid[c].length-1; r>=0; r--) {
                            const b = this.grid[c][r];
                            const bx = this.gridOffsetX + b.col * this.cellSize;
                            if (checkPoint(bx, b.y, this.cellSize, this.cellSize)) {
                                this.destroyBlock(b, 'grid', {c, r});
                            }
                        }
                    }
                }
            },

            addEffect(type) {
                if (type === 'NUKE') {
                    this.entities.blocks = [];
                    this.grid = Array(CONFIG.COLS).fill(null).map(()=>[]);
                    this.activeEffects.set('NUKE', 0.5);
                    this.shake = 20;
                    Audio.sfx.explode();
                    return;
                }

                const dur = POWERUPS[type].duration;
                if (this.activeEffects.has(type)) {
                    this.activeEffects.set(type, this.activeEffects.get(type) + dur);
                } else {
                    this.activeEffects.set(type, dur);
                }
                UI.renderEffects();
            },

            loop(now) {
                const dt = now - this.lastTime;
                this.lastTime = now;

                if (this.infiniteMoney) {
                    if (Data.profile.coins < 999999) Data.profile.coins = 999999;
                    if (this.state === 'MENU') {
                        UI.updateMenuStats();
                        const shopCoins = document.getElementById('shop-coins');
                        if (shopCoins) shopCoins.innerText = Data.profile.coins;
                    } else if (this.state === 'PLAYING') {
                        UI.updateHUD();
                    }
                }

                if (this.state !== 'PLAYING') {
                    this.drawBackground(now);
                    this.loopId = requestAnimationFrame(t => this.loop(t));
                    return;
                }

                for (const [key, val] of this.activeEffects) {
                    const newVal = val - dt;
                    if (newVal <= 0) {
                        this.activeEffects.delete(key);
                        UI.renderEffects();
                    } else {
                        this.activeEffects.set(key, newVal);
                    }
                }
                if (this.activeEffects.has('NUKE')) this.shake = 10;

                if (this.mouse.down && this.activeEffects.has('MINIGUN')) {
                    if (now - this.timers.shot > (CONFIG.MINIGUN_FIRE_RATE - Data.profile.upgrades.rate * 5)) {
                        this.fireWeapon();
                        this.timers.shot = now;
                    }
                }

                const adrenaline = Data.profile.upgrades.adrenaline || 0;
                let spawnTime = Math.max(250, 900 - (this.score * 0.6) - (adrenaline * 60));

                if (this.timers.spawn > spawnTime) {
                    this.spawnBlock();
                    this.timers.spawn = 0;
                }
                this.timers.spawn += dt;

                const timeScale = dt / 16.67;
                if (this.gunRecoil > 0.1) this.gunRecoil *= 0.85;
                if (this.muzzleFlash > 0) this.muzzleFlash--;

                const floorY = this.height - CONFIG.GRID_MARGIN_BOTTOM;
               
                // Falling Block Logic
                for(let i=this.entities.blocks.length-1; i>=0; i--) {
                    const b = this.entities.blocks[i];
                   
                    // Speed Calculation
                    let fallSpeed = (180 + (this.score * 0.5) + (adrenaline * 50)) * (dt/1000);
                    if (b.type === 'BOSS') fallSpeed *= 0.5; // Slower boss

                    b.y += fallSpeed;
                   
                    // Landing Logic
                    let landY;
                    if (b.type === 'BOSS') {
                        // Boss checks two columns
                        let y1 = floorY - this.cellSize;
                        if (this.grid[b.col].length > 0) y1 = this.grid[b.col][this.grid[b.col].length-1].targetY - this.cellSize;
                       
                        let y2 = floorY - this.cellSize;
                        if (this.grid[b.col+1].length > 0) y2 = this.grid[b.col+1][this.grid[b.col+1].length-1].targetY - this.cellSize;
                       
                        landY = Math.min(y1, y2); // Sits on highest stack (lowest Y)
                        // Adjust landY upwards because Boss is 2 cells tall
                        landY -= this.cellSize; // Boss height is 2*cell, y1/y2 account for 1 cell
                    } else {
                        landY = floorY - this.cellSize;
                        if (this.grid[b.col].length > 0) landY = this.grid[b.col][this.grid[b.col].length-1].targetY - this.cellSize;
                    }

                    if (b.y >= landY) {
                        b.y = landY;
                       
                        if (b.type === 'BOSS') {
                            // Boss solidification: Turns into 4 blocks
                            const color = b.color;
                            // Left Col (Top, Bottom)
                            this.grid[b.col].push({ col: b.col, y: landY + this.cellSize, w: this.cellSize-6, h: this.cellSize-6, color, targetY: landY + this.cellSize, landTime: now });
                            this.grid[b.col].push({ col: b.col, y: landY, w: this.cellSize-6, h: this.cellSize-6, color, targetY: landY, landTime: now });
                            // Right Col (Top, Bottom)
                            this.grid[b.col+1].push({ col: b.col+1, y: landY + this.cellSize, w: this.cellSize-6, h: this.cellSize-6, color, targetY: landY + this.cellSize, landTime: now });
                            this.grid[b.col+1].push({ col: b.col+1, y: landY, w: this.cellSize-6, h: this.cellSize-6, color, targetY: landY, landTime: now });
                           
                            this.shake = 10;
                            Audio.sfx.explode();
                        } else {
                            b.targetY = landY;
                            this.grid[b.col].push({ ...b, landTime: now });
                            this.shake = 2;
                            Audio.sfx.hit(); // Subtle land sound re-using hit
                        }
                       
                        this.entities.blocks.splice(i, 1);
                        if (b.y <= CONFIG.DANGER_Y) this.end();
                    }
                }

                // Update Grid Positions
                this.grid.forEach(col => {
                    col.forEach((b, r) => {
                        const target = floorY - this.cellSize - (r * this.cellSize);
                        b.targetY = target;
                        if(b.y < target) b.y += 10; // Snap down fast
                        if(b.y > target) b.y = target;
                    });
                });

                this.entities.powerups.forEach((p, i) => {
                    p.y += p.vy * timeScale;
                    if(p.y > this.height) this.entities.powerups.splice(i, 1);
                });

                // Bullets
                for(let i=this.entities.bullets.length-1; i>=0; i--) {
                    const b = this.entities.bullets[i];
                    if (b.type === 'LASER') {
                        b.life -= dt/1000;
                        if (b.life <= 0) this.entities.bullets.splice(i, 1);
                        continue;
                    }

                    b.x += b.vx * timeScale;
                    b.y += b.vy * timeScale;

                    if (b.y < -50 || b.x < 0 || b.x > this.width || b.y > this.height) {
                        this.entities.bullets.splice(i, 1);
                        continue;
                    }

                    // Collision Powerups
                    let hitP = false;
                    for(let j=this.entities.powerups.length-1; j>=0; j--) {
                        const p = this.entities.powerups[j];
                        if (Math.hypot(b.x - p.x, b.y - p.y) < 35) {
                            this.addEffect(p.type);
                            this.createExplosion(p.x, p.y, POWERUPS[p.type].color);
                            this.entities.powerups.splice(j, 1);
                            hitP = true; break;
                        }
                    }
                    if(hitP) { this.entities.bullets.splice(i, 1); continue; }

                    // Collision Blocks
                    let hitB = false;
                   
                    // Check falling blocks (Boss & Normal)
                    for(let j=this.entities.blocks.length-1; j>=0; j--) {
                        const bk = this.entities.blocks[j];
                        const bx = this.gridOffsetX + bk.col * this.cellSize;
                        // For collision, use block's own dimensions
                        if (b.x > bx && b.x < bx + bk.w && b.y > bk.y && b.y < bk.y + bk.h) {
                            this.handleBulletHit(b, bk, 'falling', j);
                            hitB = true; break;
                        }
                    }
                   
                    // Check grid
                    if(!hitB) {
                         outer: for(let c=0; c<CONFIG.COLS; c++) {
                             for(let r=this.grid[c].length-1; r>=0; r--) {
                                 const bk = this.grid[c][r];
                                 const bx = this.gridOffsetX + bk.col * this.cellSize;
                                 if (b.x > bx && b.x < bx + bk.w && b.y > bk.y && b.y < bk.y + bk.h) {
                                     this.handleBulletHit(b, bk, 'grid', {c,r});
                                     hitB = true; break outer;
                                 }
                             }
                          }
                    }

                    if(hitB) this.entities.bullets.splice(i, 1);
                }

                for(let i=this.entities.particles.length-1; i>=0; i--) {
                    const p = this.entities.particles[i];
                    p.x += p.vx * timeScale;
                    p.y += p.vy * timeScale;
                    p.life -= 0.02 * timeScale;
                    if(p.life <= 0) this.entities.particles.splice(i, 1);
                }

                if (this.shake > 0) this.shake *= 0.9;
               
                this.draw(now);
                this.loopId = requestAnimationFrame(t => this.loop(t));
            },

            handleBulletHit(bullet, block, type, index) {
                if (block.type === 'BOSS') {
                    // Boss logic
                    block.hp--;
                    this.createExplosion(block.x + this.gridOffsetX + block.w/2, block.y + block.h, '#fff'); // Small spark
                    Audio.sfx.bossHit();
                   
                    if (block.hp <= 0) {
                        this.destroyBlock(block, type, index);
                        this.score += 500; // Bonus for boss
                        this.sessionCoins += 50;
                        this.shake = 15;
                        Audio.sfx.explode();
                        UI.updateHUD();
                    } else {
                        // Flash effect could go here
                        block.flash = 5;
                    }
                    return;
                }

                if (bullet.type === 'BOMB') {
                    this.createExplosion(block.x + this.gridOffsetX + 20, block.y + 20, '#e74c3c');
                    this.explodeArea(block.col, block.y);
                    Audio.sfx.explode();
                    this.shake = 5;
                } else {
                    this.destroyBlock(block, type, index);
                    Audio.sfx.hit();
                }
            },

            explodeArea(col, y) {
                const minC = Math.max(0, col-1);
                const maxC = Math.min(CONFIG.COLS-1, col+1);
               
                for(let i=this.entities.blocks.length-1; i>=0; i--) {
                    const b = this.entities.blocks[i];
                    // Don't insta-kill boss with bomb, just damage
                    if (b.type === 'BOSS') {
                        if (Math.abs(b.y - y) < 100) b.hp -= 5;
                        continue;
                    }
                    if (b.col >= minC && b.col <= maxC && Math.abs(b.y - y) < this.cellSize * 1.5) {
                        this.destroyBlock(b, 'falling', i);
                    }
                }
               
                for(let c=minC; c<=maxC; c++) {
                    for(let r=this.grid[c].length-1; r>=0; r--) {
                        const b = this.grid[c][r];
                        if (Math.abs(b.y - y) < this.cellSize * 1.5) {
                            this.destroyBlock(b, 'grid', {c, r});
                        }
                    }
                }
            },

            destroyBlock(block, type, index) {
                const bx = this.gridOffsetX + block.col * this.cellSize;
                // Center explosion based on block width
                this.createExplosion(bx + (block.w||this.cellSize)/2, block.y + (block.h||this.cellSize)/2, block.color);
               
                if (type === 'falling') {
                    this.entities.blocks.splice(index, 1);
                } else {
                    this.grid[index.c].splice(index.r, 1);
                }

                this.score += 10;
                const greedBonus = 1 + (Data.profile.upgrades.greed * 0.1);
                this.sessionCoins += Math.ceil(10 * greedBonus);
                UI.updateHUD();
            },

            createExplosion(x, y, color) {
                for(let i=0; i<12; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 6 + 2;
                    this.entities.particles.push({
                        x, y, color,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 1.0, size: Math.random() * 6 + 3
                    });
                }
            },

            drawBackground(now) {
                const type = Data.profile.equippedBg;
               
                if (type === 'bg_vapor') {
                    const grd = this.ctx.createLinearGradient(0, 0, 0, this.height);
                    grd.addColorStop(0, "#2c3e50");
                    grd.addColorStop(0.5, "#8e44ad");
                    grd.addColorStop(1, "#c0392b");
                    this.ctx.fillStyle = grd;
                    this.ctx.fillRect(0, 0, this.width, this.height);
                   
                    this.ctx.fillStyle = '#f1c40f';
                    this.ctx.beginPath();
                    this.ctx.arc(this.width/2, this.height*0.6, 100, 0, Math.PI*2);
                    this.ctx.fill();
                    this.ctx.fillStyle = '#c0392b';
                    for(let i=0; i<6; i++) {
                        this.ctx.fillRect(this.width/2 - 110, this.height*0.6 + 20 + (i*12), 220, 4);
                    }

                    this.ctx.strokeStyle = 'rgba(255, 105, 180, 0.3)';
                    this.ctx.lineWidth = 2;
                    const horizon = this.height * 0.6;
                    for (let i = 0; i < 10; i++) {
                        const y = horizon + (Math.pow(i/10, 2) * (this.height - horizon));
                        this.ctx.beginPath();
                        this.ctx.moveTo(0, y);
                        this.ctx.lineTo(this.width, y);
                        this.ctx.stroke();
                    }
                    for (let i = -10; i <= 20; i++) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(this.width/2 + (i * 100), this.height);
                        this.ctx.lineTo(this.width/2 + (i * 20), horizon);
                        this.ctx.stroke();
                    }

                } else if (type === 'bg_midnight') {
                    const grd = this.ctx.createLinearGradient(0, 0, 0, this.height);
                    grd.addColorStop(0, "#000000");
                    grd.addColorStop(1, "#1a252f");
                    this.ctx.fillStyle = grd;
                    this.ctx.fillRect(0, 0, this.width, this.height);
                   
                    this.ctx.fillStyle = 'white';
                    this.entities.stars.forEach(s => {
                        this.ctx.globalAlpha = 0.5 + Math.sin(now*0.005 + s.x)*0.5;
                        this.ctx.beginPath();
                        this.ctx.arc(s.x, s.y, s.size, 0, Math.PI*2);
                        this.ctx.fill();
                    });
                    this.ctx.globalAlpha = 1.0;

                } else if (type === 'bg_emerald') {
                    const grd = this.ctx.createLinearGradient(0, 0, 0, this.height);
                    grd.addColorStop(0, "#145A32");
                    grd.addColorStop(1, "#1E8449");
                    this.ctx.fillStyle = grd;
                    this.ctx.fillRect(0, 0, this.width, this.height);
                   
                    const drawHill = (yOff, color, speed) => {
                        this.ctx.fillStyle = color;
                        this.ctx.beginPath();
                        this.ctx.moveTo(0, this.height);
                        for(let x=0; x<=this.width; x+=50) {
                            const y = Math.sin(x * 0.005 + now * speed) * 30 + this.height - yOff;
                            this.ctx.lineTo(x, y);
                        }
                        this.ctx.lineTo(this.width, this.height);
                        this.ctx.fill();
                    }
                   
                    drawHill(200, '#196F3D', 0.0002);
                    drawHill(120, '#229954', 0.0005);
                    drawHill(50, '#27AE60', 0.001);

                } else {
                    this.ctx.fillStyle = '#f4f7f6';
                    this.ctx.fillRect(0, 0, this.width, this.height);
                }

                // --- BRIGHTNESS TINT REDUCED ---
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
                this.ctx.fillRect(0, 0, this.width, this.height);
            },

            draw(now) {
                this.drawBackground(now);

                this.ctx.save();
                const dx = (Math.random()-0.5)*this.shake;
                const dy = (Math.random()-0.5)*this.shake;
                this.ctx.translate(dx, dy);

                const gridW = CONFIG.COLS * this.cellSize;
                const floorY = this.height - CONFIG.GRID_MARGIN_BOTTOM;
               
                this.ctx.strokeStyle = Data.profile.equippedBg === 'bg_clean' ? '#e0e5e9' : 'rgba(255,255,255,0.2)';
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                for(let i=0; i<=CONFIG.COLS; i++) {
                    const x = this.gridOffsetX + i * this.cellSize;
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, floorY);
                }
                this.ctx.stroke();

                this.ctx.fillStyle = '#bdc3c7';
                this.ctx.beginPath();
                this.ctx.roundRect(this.gridOffsetX - 10, floorY, gridW + 20, 8, 4);
                this.ctx.fill();

                this.ctx.strokeStyle = '#ff7675';
                this.ctx.setLineDash([10, 10]);
                this.ctx.beginPath();
                this.ctx.moveTo(this.gridOffsetX - 20, CONFIG.DANGER_Y);
                this.ctx.lineTo(this.gridOffsetX + gridW + 20, CONFIG.DANGER_Y);
                this.ctx.stroke();
                this.ctx.setLineDash([]);

                const drawB = (b) => {
                    const x = this.gridOffsetX + b.col * this.cellSize + 3;
                   
                    let sx = 1, sy = 1;
                    if (b.landTime) {
                        const t = now - b.landTime;
                        if (t < 400) {
                            const amp = Math.exp(-t * 0.01) * 0.3;
                            const freq = 0.02;
                            sy = 1 - Math.sin(t * freq) * amp;
                            sx = 1 + Math.sin(t * freq) * amp;
                        }
                    }

                    this.ctx.save();
                    if (b.type === 'BOSS') {
                        // Flash white on hit
                        if (b.flash > 0) {
                            this.ctx.fillStyle = '#fff';
                            b.flash--;
                        } else {
                            this.ctx.fillStyle = '#34495e'; // Dark color for boss
                        }
                        this.roundRect(x, b.y+3, b.w, b.h, 12);
                        this.ctx.fill();
                       
                        // Boss Eye
                        this.ctx.fillStyle = '#e74c3c';
                        this.ctx.beginPath();
                        this.ctx.arc(x + b.w/2, b.y + b.h/2, 20, 0, Math.PI*2);
                        this.ctx.fill();
                       
                        // Health Bar
                        const hpPct = b.hp / b.maxHp;
                        this.ctx.fillStyle = '#000';
                        this.ctx.fillRect(x + 10, b.y - 15, b.w - 20, 8);
                        this.ctx.fillStyle = '#2ecc71';
                        this.ctx.fillRect(x + 10, b.y - 15, (b.w - 20) * hpPct, 8);
                    } else {
                        const cx = x + b.w/2;
                        const cy = b.y + 3 + b.h/2;
                        this.ctx.translate(cx, cy);
                        this.ctx.scale(sx, sy);
                        this.ctx.translate(-cx, -cy);

                        this.ctx.fillStyle = b.color;
                        this.roundRect(x, b.y+3, b.w, b.h, 8);
                        this.ctx.fill();
                        this.ctx.fillStyle = 'rgba(255,255,255,0.25)';
                        this.ctx.beginPath();
                        this.roundRect(x, b.y+3, b.w, b.h/2.5, [8,8,0,0]);
                        this.ctx.fill();
                    }
                    this.ctx.restore();
                };

                this.grid.forEach(col => col.forEach(drawB));
                this.entities.blocks.forEach(drawB);

                this.entities.powerups.forEach(p => {
                    const pulse = 1 + Math.sin(now * 0.008) * 0.1;
                    this.ctx.save();
                    this.ctx.translate(p.x, p.y);
                    this.ctx.scale(pulse, pulse);
                    this.ctx.shadowColor = POWERUPS[p.type].color;
                    this.ctx.shadowBlur = 20;
                    this.ctx.fillStyle = POWERUPS[p.type].color;
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, 22, 0, Math.PI*2);
                    this.ctx.fill();
                    this.ctx.shadowBlur = 0;
                    this.ctx.strokeStyle = 'white';
                    this.ctx.lineWidth = 3;
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, 16, 0, Math.PI*2);
                    this.ctx.stroke();
                    this.ctx.fillStyle = '#fff';
                    this.ctx.font = '900 14px Inter';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText(p.type[0], 0, 2);
                    this.ctx.restore();
                });

                this.entities.bullets.forEach(b => {
                    if (b.type === 'LASER') {
                         this.ctx.save();
                         this.ctx.translate(b.x, b.y);
                         this.ctx.rotate(b.angle);
                         this.ctx.fillStyle = `rgba(142, 68, 173, ${b.life * 5})`;
                         this.ctx.fillRect(0, -4, 1000, 8);
                         this.ctx.fillStyle = 'rgba(255,255,255,0.8)';
                         this.ctx.fillRect(0, -1, 1000, 2);
                         this.ctx.restore();
                    } else {
                        this.ctx.fillStyle = b.color;
                        this.ctx.beginPath();
                        this.ctx.arc(b.x, b.y, 6, 0, Math.PI*2);
                        this.ctx.fill();
                    }
                });

                this.entities.particles.forEach(p => {
                    this.ctx.globalAlpha = p.life;
                    this.ctx.fillStyle = p.color;
                    this.ctx.beginPath();
                    this.ctx.roundRect(p.x, p.y, p.size, p.size, 2);
                    this.ctx.fill();
                    this.ctx.globalAlpha = 1.0;
                });

                this.drawGun(this.width/2, this.height, this.mouse.x, this.mouse.y);

                this.ctx.restore();
            },

            drawGun(cx, cy, mx, my) {
                const angle = Math.atan2(my - cy, mx - cx);
                this.ctx.save();
                this.ctx.translate(cx, cy);
                this.ctx.rotate(angle + Math.PI/2);
               
                const recoilY = this.gunRecoil;

                this.ctx.fillStyle = '#2c3e50';
                this.ctx.beginPath();
                this.ctx.arc(0, 0, 30, Math.PI, 0);
                this.ctx.fill();

                this.ctx.fillStyle = '#34495e';
               
                if (this.activeEffects.has('MINIGUN')) {
                    this.ctx.fillStyle = '#c0392b';
                    this.ctx.fillRect(-12, -70 + recoilY, 8, 45);
                    this.ctx.fillRect(4, -70 + recoilY, 8, 45);
                    this.ctx.fillStyle = '#2c3e50';
                    this.ctx.fillRect(-14, -40, 28, 15);
                } else if (this.activeEffects.has('LASER')) {
                    this.ctx.fillStyle = '#8e44ad';
                    this.ctx.fillRect(-8, -80 + recoilY, 16, 60);
                    this.ctx.fillStyle = '#e1b12c';
                    this.ctx.fillRect(-2, -75 + recoilY, 4, 50);
                } else {
                    this.ctx.fillStyle = '#7f8c8d';
                    this.ctx.fillRect(-6, -70 + recoilY, 12, 50);
                }

                if (this.muzzleFlash > 0) {
                    this.ctx.fillStyle = '#f1c40f';
                    this.ctx.beginPath();
                    this.ctx.arc(0, -75 + recoilY, 15 + Math.random()*5, 0, Math.PI*2);
                    this.ctx.fill();
                    this.ctx.fillStyle = '#fff';
                    this.ctx.beginPath();
                    this.ctx.arc(0, -75 + recoilY, 8, 0, Math.PI*2);
                    this.ctx.fill();
                }

                this.ctx.fillStyle = '#2c3e50';
                this.ctx.beginPath();
                this.ctx.arc(0, 0, 15, 0, Math.PI*2);
                this.ctx.fill();
                this.ctx.fillStyle = '#34495e';
                this.ctx.beginPath();
                this.ctx.arc(0, 0, 6, 0, Math.PI*2);
                this.ctx.fill();

                this.ctx.restore();

                this.ctx.strokeStyle = '#2c3e50';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.arc(mx, my, 8, 0, Math.PI*2);
                this.ctx.stroke();
                this.ctx.fillStyle = '#e74c3c';
                this.ctx.beginPath();
                this.ctx.arc(mx, my, 3, 0, Math.PI*2);
                this.ctx.fill();
            },

            roundRect(x, y, w, h, r) {
                if (typeof r === 'number') r = [r,r,r,r];
                this.ctx.beginPath();
                this.ctx.moveTo(x + r[0], y);
                this.ctx.lineTo(x + w - r[1], y);
                this.ctx.quadraticCurveTo(x + w, y, x + w, y + r[1]);
                this.ctx.lineTo(x + w, y + h - r[2]);
                this.ctx.quadraticCurveTo(x + w, y + h, x + w - r[2], y + h);
                this.ctx.lineTo(x + r[3], y + h);
                this.ctx.quadraticCurveTo(x, y + h, x, y + h - r[3]);
                this.ctx.lineTo(x, y + r[0]);
                this.ctx.quadraticCurveTo(x, y, x + r[0], y);
                this.ctx.closePath();
            }
        };

        const UI = {
            currentShopTab: 'upgrades',
            lbInterval: null,
           
            hideScreens() {
                document.querySelectorAll('.screen').forEach(el => el.classList.remove('active'));
                if (this.lbInterval) {
                    clearInterval(this.lbInterval);
                    this.lbInterval = null;
                }
            },
            showMenu() {
                this.hideScreens();
                document.getElementById('screen-menu').classList.add('active');
                Game.canvas.classList.add('blurred');
                this.updateMenuStats();
            },
            showShop() {
                this.hideScreens();
                document.getElementById('screen-shop').classList.add('active');
                Game.canvas.classList.add('blurred');
                this.renderShop();
            },
            showLeaderboard() {
                this.hideScreens();
                document.getElementById('screen-leaderboard').classList.add('active');
               
                // Initial fetch
                this.updateLeaderboardTable();

                // Refresh every 30s
                this.lbInterval = setInterval(() => {
                    this.updateLeaderboardTable();
                }, 30000);
            },
            async updateLeaderboardTable() {
                const tb = document.getElementById('lb-body');
                // Only show loading text if table is effectively empty (first load)
                if (tb.rows.length <= 1 && tb.innerText.includes('Connecting')) {
                     tb.innerHTML = '<tr><td colspan="3">Connecting to mainframe...</td></tr>';
                }
               
                const scores = await Leaderboard.fetchTop10();
               
                // Ensure screen is still active before updating DOM
                if (!document.getElementById('screen-leaderboard').classList.contains('active')) return;

                if(scores.length === 0) {
                    tb.innerHTML = '<tr><td colspan="3">No records found.</td></tr>';
                } else {
                    tb.innerHTML = '';
                    scores.forEach((s, i) => {
                        const tr = document.createElement('tr');
                        tr.innerHTML = `<td class="rank-cell">${i+1}</td><td>${s.name}</td><td style="text-align:right">${s.score}</td>`;
                        tb.appendChild(tr);
                    });
                }
            },
            setShopTab(tab) {
                this.currentShopTab = tab;
                document.querySelectorAll('.shop-tab').forEach(el => el.classList.remove('active'));
                document.querySelector(`.shop-tab[onclick*="${tab}"]`).classList.add('active');
                this.renderShop();
            },
            updateMenuStats() {
                document.getElementById('menu-score').innerText = Data.profile.highScore;
                document.getElementById('menu-coins').innerText = Data.profile.coins;
            },
            updateHUD() {
                document.getElementById('hud-score').innerText = Game.score;
                document.getElementById('hud-coins').innerText = Game.sessionCoins;
            },
            renderEffects() {
                const container = document.getElementById('active-effects');
                container.innerHTML = '';
                for (const [type, time] of Game.activeEffects) {
                    const tag = document.createElement('div');
                    tag.className = 'effect-tag';
                    tag.style.background = POWERUPS[type].color;
                    tag.innerHTML = `<span style="font-size:14px">⚡</span> ${POWERUPS[type].name} ${(time/1000).toFixed(1)}s`;
                    container.appendChild(tag);
                }
            },
            renderShop() {
                const container = document.getElementById('shop-container');
                document.getElementById('shop-coins').innerText = Data.profile.coins;
                container.innerHTML = '';

                for(const [key, conf] of Object.entries(UPGRADES)) {
                    if (conf.category !== this.currentShopTab) continue;

                    let el = document.createElement('div');
                    let price, isMax, canAfford, isOwned, isEquipped;
                   
                    if (conf.type === 'background') {
                        isOwned = Data.profile.inventory.includes(key);
                        isEquipped = Data.profile.equippedBg === key;
                        price = conf.cost;
                        canAfford = Data.profile.coins >= price;
                       
                        el.className = `shop-item ${isEquipped ? 'equipped' : ''}`;
                        if (!isOwned && !canAfford) el.classList.add('locked');
                       
                        el.onclick = () => {
                            if (!isOwned) {
                                if (canAfford) Data.buy(key);
                            } else {
                                Data.equip(key);
                            }
                        };
                       
                        let actionLabel = "BUY";
                        if (isOwned) actionLabel = isEquipped ? "EQUIPPED" : "EQUIP";
                       
                        el.innerHTML = `
                            <div>
                                <h3>${conf.name}</h3>
                                <p>${conf.desc}</p>
                            </div>
                            <div style="display:flex; justify-content:space-between; align-items:flex-end">
                                <div class="shop-price">
                                    ${!isOwned ? '<div class="coin-icon" style="width:16px;height:16px;font-size:10px"></div> ' + price : ''}
                                </div>
                                <div class="shop-action">${actionLabel}</div>
                            </div>
                        `;
                    } else {
                        const lvl = Data.profile.upgrades[key];
                        isMax = lvl >= conf.max;
                        price = Math.floor(conf.cost * Math.pow(1.5, lvl));
                        canAfford = Data.profile.coins >= price;
                       
                        el.className = `shop-item ${!canAfford && !isMax ? 'locked' : ''}`;
                        el.onclick = () => { if(!isMax) Data.buy(key); };
                       
                        el.innerHTML = `
                            <div class="shop-lvl">${isMax ? 'MAX' : 'Lvl '+lvl}</div>
                            <h3 style="color:${key.includes('unlock') ? '#9b59b6' : '#2c3e50'}">${conf.name}</h3>
                            <p>${conf.desc}</p>
                            <div class="shop-price">
                                 ${isMax ? 'SOLD OUT' : '<div class="coin-icon" style="width:16px;height:16px;font-size:10px"></div> ' + price}
                            </div>
                        `;
                    }
                    container.appendChild(el);
                }
            }
        };

        // Attach to window so HTML onClicks work with module scope
        window.Game = Game;
        window.UI = UI;
        window.Music = Music;
        window.Data = Data;
       
        // ADMIN EXPORTS
        window.toggleAdmin = function() {
            const p = document.getElementById('admin-panel');
            p.style.display = p.style.display === 'none' ? 'block' : 'none';
        }
        window.adminAddMoney = function() {
            const amt = parseInt(document.getElementById('inp-money').value);
            Data.profile.coins += amt;
            Data.save();
            UI.renderShop();
        }
        window.adminSetMoney = function(val) {
            Data.profile.coins = val;
            Data.save();
            UI.renderShop();
        }
        document.getElementById('chk-inf-money').addEventListener('change', (e) => {
            Game.infiniteMoney = e.target.checked;
        });

        // START
        Game.init();
        UI.showMenu();

    </script>
</body>
</html>
